#pragma config(Sensor, dgtl1,  		Prox1,               sensorTouch)
#pragma config(Sensor, dgtl2,  		Prox2,               sensorTouch)
#pragma config(Sensor, dgtl3,  		Prox3,               sensorTouch)
#pragma config(Sensor, dgtl4,  		Prox4,               sensorTouch)
#pragma config(Sensor, dgtl5,  		inputEnableRPI,		 sensorTouch)
#pragma config(Sensor, dgtl6,  		inputFinMedirRPI,    sensorTouch)
#pragma config(Sensor, dgtl7,  		inputConexionRPI,    sensorTouch)
#pragma config(Sensor, dgtl8,  		inicioRPI,           sensorDigitalOut)
#pragma config(Sensor, dgtl9,  		medirRPI,            sensorDigitalOut)
#pragma config(Sensor, dgtl10,  	finRPI,         	 sensorDigitalOut)
#pragma config(Motor,  port2,       motor2,              tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,       motor3,              tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,    	motor4,              tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,       motor1,              tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{
	int state=0;
	int medida=0;

	while(true){

		if(state == 0){// Inicializar variables hacia la RPI en OFF
			medida=0;
			SensorValue[inicioRPI] = 0;
			SensorValue[finRPI] = 0;
			SensorValue[medirRPI] = 0;

			state=1;
		}
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		else if(state == 1){ /* Verificar si la se√±al de INICIO de recorrido se presiono en el Joystick para iniciar
			el RECORRIDO DE ADQUISI√?N*/
			if(vexRT(Btn7L) == 1){ //Bot√≥n de Inicio
				SensorValue[inicioRPI] = 1;
				state=2;
			}
			else{
				//motores OFF
				motor[motor1] = 0;
				motor[motor2] = 0;
				motor[motor3] = 0;
				motor[motor4] = 0;

				state=1;
			}
		}
		//////////////////////////////////////////////////////////////////////////////////////////////////////////
		else if(state==2){/*BLOQUE DE MOVIMIENTO DE MOTORES Y PROX., esperando la se√±al de MEDIR del
			Joystick*/

			motor[motor1] = vexRT(Btn5U)*60-vexRT(Btn5D)*60;
			motor[motor2] = vexRT(Btn5U)*60-vexRT(Btn5D)*60;
			motor[motor3] = -(vexRT(Btn6U)*60-vexRT(Btn6D)*60);
			motor[motor4] = -(vexRT(Btn6U)*60-vexRT(Btn6D)*60);

			if(vexRT(Btn7D) == 1){ //Bot√≥n Medir
				medida=medida+1;
				SensorValue[medirRPI] = 1;
				state=3;
			}
			else if ( (vexRT(Btn7R) == 1)  && (medida > 0) ){ //Bot√≥n Fin
				SensorValue[inicioRPI] = 0;
				SensorValue[finRPI] = 1;
				state=4;
			}
			else{
				if(SensorValue[Prox1] == 1){ //Revisa se√±al de Proximidad 1
					// retrocede cuando hay objeto adelante
					motor[motor1] = 60;
					motor[motor2] = 60;
					motor[motor3] = -60;
					motor[motor4] = -60;
					wait1Msec(1000);
				}
				/*--------------------------------------------------------------------*/
				if(SensorValue[Prox2] == 1){ //Revisa se√±al de Proximidad 2
					// avanza cuando hay objeto derecha
					// se paran dos motores y se mueven hacia adelante dos motores (gira a izq)
					motor[motor1] = 0;
					motor[motor2] = 0;
					motor[motor3] = 60;
					motor[motor4] = 60;
					wait1Msec(500);
				}
				/*--------------------------------------------------------------------*/
				if(SensorValue[Prox3] == 1){ //Revisa se√±al de Proximidad 3
					// avanza cuando hay objeto izquierda
					// se paran dos motores y se mueven hacia adelante dos motores (gira a derecha)
					motor[motor1] = -60;
					motor[motor2] = -60;
					motor[motor3] = 0;
					motor[motor4] = 0;
					wait1Msec(500);
				}
				/*--------------------------------------------------------------------*/
				if(SensorValue[Prox4] == 1){ //Revisa se√±al de Proximidad 4
					// retrocede cuando hay objeto atras
					motor[motor1] = -60;
					motor[motor2] = -60;
					motor[motor3] = 60;
					motor[motor4] = 60;
					wait1Msec(1000);
				}
				state=2;
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////
		else if(state==3){ /*Esperar la se√±al de la RPI que indica que ya acabo de medir*/
			//motores OFF
			motor[motor1] = 0;
			motor[motor2] = 0;
			motor[motor3] = 0;
			motor[motor4] = 0;

			if(SensorValue[inputFinMedirRPI] == 1){// RPI envia seÔøΩal cuando termina de adquirir datos
				SensorValue[medirRPI] = 0;
				state=2;
			}
			else{
				state=3;
			}
		}
		///////////////////////////////////////////////////////////////////////////////////////////////////////////
		else if(state==4){ /*Esperar la se√±al de la RPI que indica CONEXI√?N A INTERNET*/

			//MOTORES ON
			motor[motor1] = vexRT(Btn5U)*60-vexRT(Btn5D)*60;
			motor[motor2] = vexRT(Btn5U)*60-vexRT(Btn5D)*60;
			motor[motor3] = -(vexRT(Btn6U)*60-vexRT(Btn6D)*60);
			motor[motor4] = -(vexRT(Btn6U)*60-vexRT(Btn6D)*60);

			if(SensorValue[inputConexionRPI] == 1){
				SensorValue[finRPI] = 0;
				state=5;
			}
			else{
				if(SensorValue[Prox1] == 1){ //Revisa se√±al de Proximidad 1
					// retrocede cuando hay objeto adelante
					motor[motor1] = 60;
					motor[motor2] = 60;
					motor[motor3] = -60;
					motor[motor4] = -60;
					wait1Msec(2000);
				}
				/*--------------------------------------------------------------------*/
				if(SensorValue[Prox2] == 1){ //Revisa se√±al de Proximidad 2
					// avanza cuando hay objeto derecha
					// se paran dos motores y se mueven hacia adelante dos motores (gira a izq)
					motor[motor1] = 0;
					motor[motor2] = 0;
					motor[motor3] = 60;
					motor[motor4] = 60;
					wait1Msec(2000);
				}
				/*--------------------------------------------------------------------*/
				if(SensorValue[Prox3] == 1){ //Revisa se√±al de Proximidad 3
					// avanza cuando hay objeto izquierda
					// se paran dos motores y se mueven hacia adelante dos motores (gira a derecha)
					motor[motor1] = -60;
					motor[motor2] = -60;
					motor[motor3] = 0;
					motor[motor4] = 0;
					wait1Msec(2000);
				}
				/*--------------------------------------------------------------------*/
				if(SensorValue[Prox4] == 1){ //Revisa se√±al de Proximidad 4
					// retrocede cuando hay objeto atras
					motor[motor1] = -60;
					motor[motor2] = -60;
					motor[motor3] = 60;
					motor[motor4] = 60;
					wait1Msec(2000);
				}
				state=4;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////////////////
		else if(state==5){ /*Esperar la se√±al de la RPI que indica que YA ESTA LISTA PARA UN NUEVO RECORRIDO*/

			//MOTORES OFF
			motor[motor1] = 0;
			motor[motor2] = 0;
			motor[motor3] = 0;
			motor[motor4] = 0;

			if(SensorValue[inputEnableRPI] == 1){
				SensorValue[finRPI] = 0;
				state=0;
			}
			else{
				SensorValue[finRPI] = 1;
				state=5;
			}
		}
		///////////////////////////////////////////////////////////////////////////////////////////////////////////
		else{
			state=state;
		}
	}

}
